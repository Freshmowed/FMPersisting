//
//  FMPersistingModel.m
//
//  Copyright 2010 freshmowed software. All rights reserved.
//

#import "FMPersistingModel.h"
#import "FMResultSet.h"

static NSMutableDictionary *keysForColumnNamesDict;
static NSMutableDictionary *columnNamesForKeysDict;
static NSDateFormatter *descriptionDateFormatter;

@interface FMPersistingModel ()
+ (NSDictionary *) columnDict;
+ (NSDateFormatter *) descriptionDateFormatter;

+ (NSString *) sqliteDataTypeForDataType: (NSString *) aDataType;

/* This returns the method selector used to get a value from a fmdb FMResultSet. */
+ (SEL) resultSetSelectorForColumnType: (NSString *) columnType;

@end

@interface FMResultSet (FMResultSetAdditions)

- (NSNumber *) intNumberForColumn:(NSString*)columnName;
- (NSNumber *) longNumberForColumn:(NSString*)columnName;
- (NSNumber *) longLongIntNumberForColumn:(NSString*)columnName;
- (NSNumber *) boolNumberForColumn:(NSString*)columnName;
- (NSNumber *) doubleNumberForColumn:(NSString*)columnName;

@end


@implementation FMPersistingModel

+ (NSString *) tableName;
{
    NSLog(@"PerisistingModel: subclass %@ of FMPersistingModel does not implement +tableName.", NSStringFromClass(self));
    return nil;
}

+ (NSDictionary *) columns;
{
    NSLog(@"PerisistingModel: subclass %@ of FMPersistingModel does not implement +columns.", NSStringFromClass(self));
    return nil;
}

+ (NSArray *) excludedColumnNames;
{
    return nil;    
}

+ (NSDictionary *) columnDict;
{
    NSDictionary *columnInfo = [self columns];  // should be from subclass, or will be nil
    if ( !columnInfo ) return nil;

    if ( !columnNamesForKeysDict ) // set up key-to-column-name hash, if needed
        columnNamesForKeysDict = [[NSMutableDictionary alloc] initWithCapacity:[columnInfo count]];
    
    if ( ![columnNamesForKeysDict objectForKey: NSStringFromClass(self)] )
    {
        NSMutableDictionary *aDict = [NSMutableDictionary dictionary];
        [columnNamesForKeysDict setObject: aDict forKey:NSStringFromClass(self)];
        
        NSArray *columnNames = [columnInfo allKeys];
        for (NSString *columnName in columnNames) 
        {            
            [ aDict setObject: columnName 
                       forKey: [self keyForColumnName: columnName] ];
        }
        
        [aDict addEntriesFromDictionary: [self columnNamesForKeys]];
    }
    
    return columnInfo;
}

+ (NSDictionary *) columnNamesForKeys; // filled by subclasses
{
    return [NSMutableDictionary dictionary];
}

+ (NSString *) primaryKeyColumnName;
{
    return @"ID";
}

+ (BOOL) primaryKeyAutoGenerated;
{
    return YES;
}

+ (NSString *) sqliteDataTypeForDataType: (NSString *) aDataType;
{
    if (!aDataType) return @"blob";
    
    NSString *lcString = [[aDataType lowercaseString] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
    
    if ( [ lcString isEqualToString: @"int"] ||
         [ lcString isEqualToString: @"bool"] ||
         [ lcString isEqualToString: @"long"] ||
         [ lcString isEqualToString: @"long long"] ) return @"integer";

    if ( [ lcString isEqualToString: @"string"] || [ lcString isEqualToString: @"text"] ) return @"text";
    
    if ( [ lcString isEqualToString: @"float"] ||
         [ lcString isEqualToString: @"double"] ||
         [ lcString isEqualToString: @"date"] ) return @"numeric";
    
    if ( [ lcString isEqualToString: @"data"]  ||
         [ lcString isEqualToString: @"data nocopy"] ) return @"blob";
    
    return nil;
    
}

+ (NSString *) schemaStatement;
{
    NSMutableString *stmt = [NSMutableString stringWithFormat: @"create table %@ (%@ integer primary key ", [self tableName], [self primaryKeyColumnName]];

    NSDictionary *columnInfo = [self columnDict];
    NSArray *columnNames = [columnInfo allKeys];
    
    for (NSString *columnName in columnNames) 
    {
        if ( [columnName isEqualToString: [self primaryKeyColumnName]] ) continue;
        
        NSString *dataType = [columnInfo objectForKey: columnName ];
        NSString *sqliteDataType = [ self sqliteDataTypeForDataType: dataType];
        [stmt appendFormat: @", %@ %@", columnName, sqliteDataType ];
    }
    
    [stmt appendString: @")"];
    
    //NSLog(@"FMPersistingModel +schemaStatement: %@", stmt );

    return stmt;
}

+ (NSDictionary *) insertStatementWithValues: (NSDictionary *) aDict;
{
    // need string of form: "insert into table_name (ID, COLUMN_1, COLUMN_2) values (NULL, ?, ?)"
    NSMutableString *preString = [NSMutableString stringWithFormat:@"insert into %@ (%@", [self tableName], [self primaryKeyColumnName]];
    NSMutableString *preStringPopulated = [NSMutableString stringWithFormat:@"insert into %@ (%@", [self tableName], [self primaryKeyColumnName]]; //[preString mutableCopy];
    NSMutableString *endString = [NSMutableString stringWithFormat:@") values (%@ ", [self primaryKeyAutoGenerated] ? @"NULL" : [aDict objectForKey:[self primaryKeyKey]]];
    NSMutableString *endStringPopulated = [NSMutableString stringWithFormat:@") values (%@ ", [self primaryKeyAutoGenerated] ? @"NULL" 
                                                                                                                                 : [aDict objectForKey:[self primaryKeyKey]]];   
    
    NSDictionary *columnInfo = [self columnDict];
    NSArray *columnNames = [columnInfo allKeys];

    NSMutableArray *columnValues = [NSMutableArray array];
    
    for (NSString *columnName in columnNames) 
    {
        if ( [columnName isEqualToString: [self primaryKeyColumnName]] ) continue;
        
        NSObject *valueForColumn = [aDict objectForKey: [self keyForColumnName: columnName] ];
        if ( !valueForColumn ) continue;
        [columnValues addObject: valueForColumn];

        [preString appendFormat: @", %@", columnName];
        [preStringPopulated appendFormat: @", %@", columnName];
        [endString appendString: @", ?"];
        [endStringPopulated appendFormat: @", %@", [self smartQuoteValue: valueForColumn forKey:[self keyForColumnName:columnName]] ];
    }
    
    [endString appendString: @")"];
    [endStringPopulated appendString: @")"];
    [preString appendString: endString];
    [preStringPopulated appendString: endStringPopulated];
    
    //NSLog(@"FMPersistingModel +insertStatementWithValues: %@", preString );
    
    return [NSDictionary dictionaryWithObjectsAndKeys: preString, @"statement", columnValues, @"valueArray", preStringPopulated, @"populatedStmt", nil];
}

- (NSDictionary *) updateStatementForColumns: (NSArray *) columnNames;  // column NAMES, not KVC Keys
{
    // need string of form: "update table_name set COLUMN_1 = ?, COLUMN_2 = ? where ID = ?"
    NSMutableString *preString = [NSMutableString stringWithFormat:@"update %@ set ", [[self class] tableName]];
    
    NSDictionary *columnInfo = [[self class] columnDict];  // keys are column NAMES, values are data types
    if ( !columnNames ) columnNames = [columnInfo allKeys]; // column NAMES (not property keys)

    NSMutableArray *columnValues = [NSMutableArray array];
    NSNumber *IDValue = nil;
    
    BOOL first = YES;
    for (NSString *columnName in columnNames) 
    {
        NSString *keyName = [[self class] keyForColumnName: columnName]; // reverse lookup key from column name
        NSObject *valueForColumn = [self valueForKey: keyName ];  // determine  value in object from key (KVC)

        if ( [columnName isEqualToString: [[self class] primaryKeyColumnName]] ) 
        {
            IDValue = (NSNumber *) valueForColumn;
            
            if ( !IDValue )
            {
                NSLog(@"Error: FMPersistingModel -updateStatementForColumns: no primary key (%@) value for object.", [[self class] primaryKeyColumnName] );
                return nil;
            }
            continue;
        }
        
        if ( !valueForColumn ) continue; // not doing anything with nil values (maybe we should NULL)?
        
        [columnValues addObject: valueForColumn];
        
        if (!first ) [preString appendString: @","];
        
        [preString appendFormat: @" %@ = ?", columnName];
        
        first = NO;
    }
    
    [preString appendFormat: @" where %@ = ?", [[self class] primaryKeyColumnName] ];
    [columnValues addObject: [self valueForKey: [[self class] keyForColumnName: [[self class] primaryKeyColumnName]] ]];

    //NSLog(@"FMPersistingModel -updateStatementforColumns: sql:  %@", preString );
    
    return [NSDictionary dictionaryWithObjectsAndKeys: preString, @"statement", columnValues, @"valueArray", nil];
}

+ (NSArray *) columnNames;
{
    return [[self columnDict] allKeys];
}

+ (NSString *) columnNamesCSV;
{
    NSMutableString *stmt = [NSMutableString string];
    
    NSDictionary *columnInfo = [self columnDict];
    NSArray *columnNames = [columnInfo allKeys];
    
    BOOL first = YES;
    for (NSString *columnName in columnNames)
    {
        if ( [self excludedColumnNames] && [[self excludedColumnNames] containsObject:columnName] ) continue;
        
        if ( !first ) [stmt appendString: @", "];            
        first = NO;
        
        [stmt appendFormat: @"%@", columnName ];
    }

    return stmt;
}

+ (NSString *) baseQueryString;
{
    NSMutableString *result = [NSMutableString stringWithString: @"select "];
    [result appendString: [self columnNamesCSV] ];
    [result appendString: @" from "];
    [result appendString: [self tableName] ];
    [result appendString: @" "]; // convenience/insurance for appending where clauses
    return result;
}

+ (NSString *) columnNameForKey: (NSString *) aKey;
{
    return (NSString *) [[columnNamesForKeysDict objectForKey: NSStringFromClass(self)] objectForKey: aKey];
}

+ (void) setColumnName: (NSString *) aColumnName forKey: (NSString *) aKey;
{
    if ( !aColumnName || !aKey ) return;
    
    if ( !columnNamesForKeysDict ) columnNamesForKeysDict = [[NSMutableDictionary alloc] init];
    
    NSMutableDictionary *classDict = [columnNamesForKeysDict objectForKey:NSStringFromClass(self)];
    if ( !classDict )
    {
        classDict = [[NSMutableDictionary alloc] init];
        [columnNamesForKeysDict setObject: classDict forKey: NSStringFromClass(self)];
    }
    
    [classDict setObject: aColumnName forKey: aKey];
}

+ (NSString *) smartQuote: (NSString *) quote value: (id) aValue forKey: (NSString *) aKey;
{
    NSDictionary *columnInfo = [self columnDict];
    NSString *dataType = [columnInfo objectForKey: [self columnNameForKey: aKey] ];
    if ( [dataType isEqualToString: @"string" ] ) return [NSString stringWithFormat:@"%@%@%@", quote, aValue, quote];
    
    return aValue;
}

+ (NSString *) smartQuoteValue: (id) aValue forKey: (NSString *) aKey; // convenience using double quotes
{
    return [self smartQuote:@"\"" value: aValue forKey: aKey];
}

+ (NSArray *) allKeys;
{
    return [columnNamesForKeysDict allKeys];
}

+ (NSString *) convertColumnNameToKey: (NSString *) aName;
{
    NSMutableString *result = [NSMutableString string];
    
    NSArray *originalStringComponents = [aName componentsSeparatedByString: @"_"];
    
    BOOL first = YES;
    for (NSString *aComponent in originalStringComponents)
    {
        if ( [aComponent isEqualToString: @"ID"] )
            [result appendString: @"ID" ];
        else if ( first ) 
            [result appendString: [aComponent lowercaseString]];
        else
            [result appendString: [[aComponent lowercaseString] capitalizedString]];
        
        first = NO;
    }
            
    return result;
}

/* Returns the KVC key to be used for a database column.  The key can be autogenerated from the column name, converting
 * columns such as LAST_NAME to lastName, or explicitly set using setKey:forColumnName:, or addKeysForColumnNames:. */
+ (NSString *) keyForColumnName: (NSString *) aName;
{
    NSString *aKey = (NSString *) [keysForColumnNamesDict objectForKey: aName];
    
    if ( aKey ) return aKey;
    
    return [self convertColumnNameToKey: aName];
}

+ (void) setKey: (NSString *) aKey forColumnName: (NSString *) aName;
{
    if ( !keysForColumnNamesDict ) keysForColumnNamesDict = [[NSMutableDictionary alloc] init];
    
    [keysForColumnNamesDict setObject: aKey forKey: aName];
}

+ (void) addKeysForColumnNames: (NSDictionary *) aDict;
{
    if ( !keysForColumnNamesDict ) keysForColumnNamesDict = [[NSMutableDictionary alloc] init];
    
    [keysForColumnNamesDict addEntriesFromDictionary: aDict];
}

/* This method returns the FMResultSet method selector to use to extract a column's value from a result set. */
+ (SEL) resultSetSelectorForColumnType: (NSString *) aDataType;
{
    NSString *lcString = [[aDataType lowercaseString] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];

    if ( [lcString isEqualToString: @"string"] ) return @selector(stringForColumn:);

    if ( [lcString isEqualToString: @"int"] ) return @selector(intNumberForColumn:);

    if ( [lcString isEqualToString: @"long"] ) return @selector(longNumberForColumn:);
    
    if ( [lcString isEqualToString: @"long long"] ) return @selector(longLongIntNumberForColumn:);

    if ( [lcString isEqualToString: @"bool"] ) return @selector(boolNumberForColumn:);
    
    if ( [lcString isEqualToString: @"double"] ) return @selector(doubleNumberForColumn:);

    if ( [lcString isEqualToString: @"string"] ) return @selector(stringForColumn:);
    
    if ( [lcString isEqualToString: @"date"] ) return @selector(dateForColumn:);

    if ( [lcString isEqualToString: @"data"] ) return @selector(dataForColumn:);

    if ( [lcString isEqualToString: @"data"] ) return @selector(dataNoCopyForColumn:);
            
    return nil;
}

+ (FMPersistingModel *) nonPersistedObjectFromDictionary: (NSDictionary *) dict;
{
    FMPersistingModel *anObject = [[self alloc] init];
    
    for ( NSString *key in dict.allKeys )
    {
        [anObject setValue: dict[key] forKey: key];
    }
    
    return anObject;
}

+ (FMPersistingModel *) objectFromResultSet: (FMResultSet *) aResultSet;
{
    FMPersistingModel *anObject = [[self alloc] init];
    NSDictionary *columnInfo = [self columnDict];
    NSArray *columnNames = [columnInfo allKeys];
    
    for (NSString *columnName in columnNames) 
    {
        if ( [self excludedColumnNames] && [[self excludedColumnNames] containsObject:columnName] ) continue;
        NSString *dataType = [columnInfo objectForKey:columnName];
        SEL aSEL = [self resultSetSelectorForColumnType: dataType ];
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        NSObject *aValue = [aResultSet performSelector: aSEL
                                            withObject: columnName];
#pragma clang diagnostic pop
        [anObject setValue: aValue  forKey:[self keyForColumnName: columnName]];
    }
    
    anObject.hasPersisted = YES;
    
    return anObject;
}

- (id)init
{
    self = [super init];
    if (self)
    {
        _hasPersisted = NO;
    }
    return self;
}

- (NSObject *) ID;
{
    return [self valueForKey: [[self class] primaryKeyKey]];
}

+ (NSString *) primaryKeyKey;
{
    return [[self class] keyForColumnName: [[self class] primaryKeyColumnName]];
}

- (BOOL)isEqual:(id)anObject;
{
    NSString *IDKey = [[anObject class] primaryKeyKey];
    return [[self valueForKey: IDKey] isEqual: [anObject valueForKey: IDKey]];
}

+ (NSDateFormatter *) descriptionDateFormatter;
{
    if ( descriptionDateFormatter ) return descriptionDateFormatter;
    
    NSCalendar *theCalendar = [[NSCalendar alloc] initWithCalendarIdentifier: NSCalendarIdentifierGregorian];
    [theCalendar setTimeZone: [NSTimeZone localTimeZone]];
    descriptionDateFormatter = [[NSDateFormatter alloc] init];
    [descriptionDateFormatter setCalendar: theCalendar];
    [descriptionDateFormatter setDateStyle: NSDateFormatterShortStyle ];
    [descriptionDateFormatter setTimeStyle: NSDateFormatterLongStyle ];

    return descriptionDateFormatter;
}

- (NSString *) description;
{
    NSMutableString *result = [NSMutableString string];
    NSMutableDictionary *classKeys = [columnNamesForKeysDict objectForKey:NSStringFromClass([self class])];
    for (NSString *aKey in [classKeys allKeys])
    {
        NSString *dataType = [[[self class] columnDict] objectForKey:[[self class] columnNameForKey: aKey]];

        if ( [ dataType isEqualToString: @"date" ] )
        {
            NSDate *aDateValue = (NSDate *) [self valueForKey: aKey];
            [result appendFormat: @"%@: %@\n", aKey, ( aDateValue ? [[FMPersistingModel descriptionDateFormatter] stringFromDate : aDateValue] : @"nil")]; 
        }
        else if ( [dataType isEqualToString: @"data"] )
            [result appendFormat: @"%@: <blob>\n", aKey ]; 
        else
            [result appendFormat: @"%@: %@\n", aKey, ([self valueForKey: aKey] ? [self valueForKey: aKey] : @"nil")]; 
    }
    return result;
}

- (void) copyValuesFrom: (FMPersistingModel *) anotherObject;
{
    NSDictionary *columnInfo = [[self class] columnDict];
    NSArray *columnNames = [columnInfo allKeys];
    
    for (NSString *columnName in columnNames)
    {
        NSString *key = [[self class] keyForColumnName: columnName];
        if ( [key isEqualToString: [[self class] primaryKeyKey] ] ) continue;
        NSObject *value = [anotherObject valueForKey: key];
        [self setValue: value forKey: key];
    }
}

- (NSMutableDictionary *) toDictionary;
{
    NSMutableArray *keys = [NSMutableArray array];
    NSArray *columnNames = [[[self class] columnDict] allKeys];
    for (NSString *columnName in columnNames) [keys addObject: [[self class] keyForColumnName: columnName]];
    return [ self toDictionaryForKeys:keys];
}

- (NSMutableDictionary *) toDictionaryForKeys: (NSArray *) keys;
{
    NSMutableDictionary *aDict = [ NSMutableDictionary dictionary];       
    for (NSString *key in keys) 
    {
        NSObject *value = [self valueForKey: key ];
        if ( !value ) continue;
        [aDict setValue:value forKey:key];
    }
    
    return aDict;
}

- (BOOL) isBitSet: (NSUInteger) bitMask on: (NSNumber *) flags;
{
    return ([flags intValue] & bitMask ) > 0;
}

- (NSNumber *) setBit: (NSUInteger) bitMask on: (NSNumber *) bitField to: (BOOL) aBool;
{
    unsigned long field = [bitField unsignedLongValue];
    unsigned long updated = aBool ? field | bitMask : field & ~bitMask;
    return [NSNumber numberWithUnsignedLong: updated];
}


@end

@implementation FMResultSet (FMResultSetAdditions)

- (NSNumber *) intNumberForColumn:(NSString*)columnName;
{
    return [NSNumber numberWithInt: [self intForColumn: columnName]];
}

- (NSNumber *) longNumberForColumn:(NSString*)columnName;
{
    return [NSNumber numberWithLong: [self longForColumn: columnName]];
}

- (NSNumber *) longLongIntNumberForColumn:(NSString*)columnName;
{
    return [NSNumber numberWithLongLong: [self longLongIntForColumn: columnName]];
}

- (NSNumber *) boolNumberForColumn:(NSString*)columnName;
{
    return [NSNumber numberWithBool: [self boolForColumn: columnName]];
}

- (NSNumber *) doubleNumberForColumn:(NSString*)columnName;
{
    return [NSNumber numberWithDouble: [self doubleForColumn: columnName]];
}

@end
